Задача 2. 
"Реализация на класическия алгоритъм Сито на Ератостен (III век преди н.е.)
 за намиране на всички прости числа в интервал от 0 до n."

Пробвах да реша задачата не само с масив (02_arr), а и със списък (02_list).
Предполагах, че за големи стойности на n, ще бъде значително по-бавно.
Въпреки това, може да има ситуации, в които този формат на данните
да е полезен, а пък изчислението е нужно да се извърши само веднъж.

Използвах Powershell командата Measure-Command, за да измеря 
времетраенето на изпълнението на двата варианта.

За n = 100, 02_arr се изпълнява за около 26-27 милисекунди.
            02_list - за 37 милисекунди - доста добре.

Тъй като алгоритъмът използва произведението на i и j, 
лесно достигаме горната граница на int. 
Смених го на long long и стигнах малко над 500 000
( 500 000 * 500 000 = 250 000 000 000 )
Тук вече не достигаме границата на типа; по-скоро на паметта?

Интересното е, че 02_arr все още приключва за по-малко от половин секунда!
Но това е само когато я пусна през Measure-Command, при което printf()
не пише на екрана. Иначе ѝ трябват няколко секунди да изпише всички резултати.

От друга страна...
При n = 100 000, 02_list вече отнема 38-40 секунди.
При n = 150 000, минута и половина.
Осмелих се да го пусна с n = 500 000, но не го дочаках.

    Но естествено, има много по-добро решение.
Ако искаме списък от простите числа до половин милион,
просто ги изчисляваме по бързия метод и след това ги записваме в списъка.

02_final е точно това решение.
Удивителното е, че не се забелязва изобщо да е по-бавно от 02_arr:
също отнема по-малко от половин секунда при n = 500 000,
нищо че първо записваме резултатите в списък, преди да ги принтираме.